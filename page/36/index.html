<!DOCTYPE html><html><head><meta charset="utf-8" /><!--Always force latest IE rendering engine or request Chrome Frame--><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><!--Use title if it's in the page YAML frontmatter--><title>ukstudio.jp</title><link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css" /><link href="/stylesheets/normalize.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/stylesheets/all.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/stylesheets/highlight.css" media="screen" rel="stylesheet" type="text/css" /><script src="/javascripts/all.js" type="text/javascript"></script><link href="/feed.xml" rel="alternate" title="atom" type="application/atom+xml" /><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-12755601-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></head><body class="page page_36 page_36_index"><div class="cointainer-fluid"><div class="navbar navbar-default" role="navigation"><div class="container-fluid"><div class="navbar-header"><a class="navbar-brand" href="/">UKSTUDIO</a></div><div class="navbar-collapse collapse"><ul class="nav navbar-nav navbar-right"><li><a href="http://twitter.com/ukstudio">Twitter</a></li><li><a href="http://github.com/ukstudio">GitHub</a></li></ul></div></div></div></div><div class="container"><article><h1><a href="/2007/11/16/coding_rule_ruby/">2007-11-16 個人用のコーディング規約を書き始めたんよ</a></h1><hr /><div class="article-body"><a href="/coding_rule/">CodingRule</a>

とりあえずはRubyから書き始めたんよ。思ったよりまとめるのが大変。

と言うより、普段何も考えてないのがわかる。暗黙的というか、その場のフィーリングで決めてるようで以前のRubyプログラムを見なおしてみると、スペースの取り方とかメソッド・クラス名が結構バラバラ。

以下の規約も参考にしつつ、少しずつまとめてみたいと思う。

<ul>
<li>前田さんの<a href="http://shugo.net/ruby-codeconv/codeconv.html">Rubyコーディング規約</a></li>
<li>青木さんの<a href="http://www.loveruby.net/w/RubyCodingStyle.html">RubyCodingStyle</a></li>
<li>id:cho45さんの<a href="http://lab.lowreal.net/trac/wiki/CodingRule/Ruby">Ruby Language Coding Rule</a></li>
</ul>

追記(07/11/18): CodingRuleページ内のリンクが間違ってたから修正した
</div></article><article><h1><a href="/2007/11/01/ruby_fizzbuzz_2/">2007-11-01 RubyでFizzBuzz #2</a></h1><hr /><div class="article-body"><a href="http://uk-studio.net/2007/10/28/ruby_fizzbuzz/">RubyでFizzBuzz</a>の第二弾。大分スッキリしたと思うんだけどどでしょ。
<pre lang="ruby">
fizzbuzz = (1..100).map{|i|
if i%5 == 0 && i%3 == 0 : "FizzBuzz"
elsif i%5 == 0 : "Buzz"
elsif i%3 == 0 : "Fizz"
else i end
}</pre>
</div></article><article><h1><a href="/2007/10/30/ruby_prime/">2007-10-30 Rubyで素数を求めるプログラムを書いた</a></h1><hr /><div class="article-body">引数に入れた値までの素数を配列で返すRubyのクラスを書いてみた。アルゴリズムは<a href="http://ja.wikipedia.org/wiki/%E3%82%A8%E3%83%A9%E3%83%88%E3%82%B9%E3%83%86%E3%83%8D%E3%82%B9%E3%81%AE%E7%AF%A9">エラトステネスの篩</a>を使用。
<strong>generate_prime.rb</strong>
<pre lang="ruby">
class GeneratePrime
  def generate_prime(max_num)
    if max_num < 2 then return nil
    elsif max_num == 2 then return 2 end

    search_list = (2..max_num).to_a # 探索リスト
    prime_list = Array.new          # 素数リスト

    # 素数の探索
    begin
      prime_list << search_list[0]
      search_list.each_index{|i|
        if search_list[i] % prime_list[-1] == 0 then
          search_list.delete_at(i)  # 素数リストに加えた数の全ての倍数を削除
        end
      }
    end while search_list[-1] > (prime_list[-1] * prime_list[-1])

    # 素数リスト及び、探索リストに最後まで残っていた数が素数
    return prime_list.concat(search_list)
  end
end</pre>
<strong>generate_prime_test.rb</strong>
<pre lang="ruby">
require 'test/unit'
require 'generate_prime'

class TestGeneratePrime < Test::Unit::TestCase
  def setup
    @prime = GeneratePrime.new
  end
  def test_generate_prime
    assert_equal(nil, @prime.generate_prime(1))
    assert_equal([2,3,5,7], @prime.generate_prime(10))
    assert_equal([2,3,5,7,11,13,17,19,23,29], @prime.generate_prime(30))
  end
end</pre>
<strong>テスト結果</strong>
</pre><pre>
% ruby generate_prime_test.rb
Loaded suite generate_prime_test
Started
.
Finished in 0.000454 seconds.

1 tests, 3 assertions, 0 failures, 0 errors</pre>
テストが不十分な気もするけど多分大丈夫なはず。・・・多分。
</div></article><article><h1><a href="/2007/10/28/ruby_fizzbuzz/">2007-10-28 RubyでFizzBuzz</a></h1><hr /><div class="article-body">今更ながらにFizzBuzz問題をRubyで問いてみる。前は確かPHPだけで問いて、Rubyで問いてなかったと思うから。

<strong>ループ内で出力</strong>
<pre lang="ruby">
100.times(){|i|
  i += 1
  if i%5 == 0 && i%3 == 0 then
    puts "FizzBuzz"
  elsif i%5 == 0
    puts "Buzz"
  elsif i%3 == 0
    puts "Fizz"
  else
    puts i
  end
}</pre>
<strong>配列を作ってそれを出力</strong>
<pre lang="ruby">
fizzbuzz = Array.new(100){|i|
  i += 1
  if i%5 == 0 && i%3 == 0 then
    "FizzBuzz"
  elsif i%5 == 0
    "Buzz"
  elsif i%3 == 0
    "Fizz"
  else
    i
  end
}
puts fizzbuzz</pre>
まぁ、普通ですな。後々データを再利用する可能性を考えると、ループ内で出力するより配列を作った方がいいかなとは思う。

if文のところはもうちょっとなんとかなる気もするけど、コードゴルフしてるわけでもないし、これでいいかな。再帰で書けって言われたら多分できないけど。

精進ですなー。
</div></article><article><h1><a href="/2007/10/28/activerecord/">2007-10-28 ActiveRecordを使ってみる</a></h1><hr /><div class="article-body">ActiveRecordはRubyOnRailsのO/Rマッパーとして有名ですが、Railsに依存しているわけではなく単体で使えます。

<h2>DBを用意する</h2>
なにはともあれ、DBがないと始まらないので適当に用意します。

<pre lang="sql">create database ar;
 use ar;
 create table users (
   id int unsigned not null auto_increment,
   name varchar(50),
   age int,
   primary key (id)
 );
</pre>

ユーザ名と年齢を管理するテーブルってことで。

<h2>DBへの接続とマッピング</h2>

<pre lang="ruby">
require 'rubygems'
require_gem 'activerecord'

# ARで接続
ActiveRecord::Base.establish_connection(
  :adapter    =>      'mysql',
  :host       =>      'localhost',
  :username   =>      'ユーザ名',
  :password   =>      'パスワード',
  :database   =>      'ar',
  :socket     =>      '/tmp/mysql.sock'
)

# マッピングクラスを定義
class User < ActiveRecord::Base
end
</pre>

データベースへのコネクションはActiveRecord::Base.establish_connectionで作られます。特にむずかしいところはないですね。socketは必ず書く必要はないです。書かない場合は/tmp/mysql.sockを見にいくのかな。

ActiveRecord::Baseを継承することでマッピングクラスを定義することができます。クラス名がUserusersテーブルへのマッピングを定義していることになります。クラスを単数形、テーブル名を複数形にすることで自動的にマッピングされます。いわゆるCoC(Convention over Configuration)ってやつです。

<h2>データの保存</h2>
newメソッド、もしくはcreateメソッドを使用し、ARオブジェクトを作成することでDBにデータを保存(Insert)することができます。newとcreateの違いは、newは明示的にsaveメソッドを実行する必要があり、createは自動的にsaveメソッドも実行されます。

</pre><pre lang="ruby">
# ARオブジェクトを作成
user = User.new(:name => "UK", :age => 20)
user.save    # DBに格納
</pre>

<pre lang="ruby">
# ARオブジェクトを作成
user = User.create(:name => "UK", :age =>20) # この時点でDBに格納される
</pre>

<img src="http://farm3.static.flickr.com/2121/1590439456_c3203f167b.jpg?v=0" />

<h2>データの検索</h2>
<img src="http://farm3.static.flickr.com/2137/1786644895_9bfe2b148c.jpg?v=0" />
データが1件だけじゃ少ないので数件ほど追加しました。

データの検索(Select)にはfindメソッドを使用します。他にもfind_allとか、find_by_sqlとかあるけどとりあえずfindのみの説明で。ちなみにfind_allは非推奨的な雰囲気。find(:all)を使えってことですね。

<blockquote>
DEPRECATION WARNING: find_all is deprecated and will be removed from Rails 2.0 ( use find(:all, ...)) See http://www.rubyonrails.org/deprecation for details.
</blockquote>

<h3>findメソッド</h3>
findメソッドの引数にIDを指定することで、該当するデータのオブジェクトが得られます。IDは複数指定することが可能でその場合の戻り値は配列です。:allを指定すると、 全件分のオブジェクトが得られます。こちらの場合も配列です。:firstを指定すると、先頭のオブジェクトを得られます。

<pre lang="ruby">
p User.find(1) # ID = 1のオブジェクト
=> #<user :0x147fbe8 @attributes={"name"=>"UK", "id"=>"1", "age"=>"20"}>
p User.find(1,4) # ID =1, ID = 4 のオブジェクトを格納した配列
=> [#</user><user :0x1476ed0 @attributes={"name"=>"UK", "id"=>"1", "age"=>"20"}>,
 #</user><user :0x147709c @attributes={"name"=>"bar", "id"=>"4", "age"=>"38"}>]
p User.find([2]) # ID = 2のオブジェクトを格納した配列
=> [#</user><user :0x14711d8 @attributes={"name"=>"hoge", "id"=>"2", "age"=>"40"}>]
p User.find(:all) # 全件分のオブジェクトを格納した配列
=> [#</user><user :0x140fca8 @attributes={"name"=>"UK", "id"=>"1", "age"=>"20"}>, #</user><user :0x140fc94 @attributes={"name"=>"hoge", "id"=>"2", "age"=>"40"}>, #</user><user :0x140fc6c @attributes={"name"=>"foo", "id"=>"3", "age"=>"14"}>, #</user><user :0x140fc44 @attributes={"name"=>"bar", "id"=>"4", "age"=>"38"}>]
p User.find(:first) # 先頭のオブジェクト
=> #</user><user :0x140cd28 @attributes={"name"=>"UK", "id"=>"1", "age"=>"20"}>
</user></pre>

各カラムのデータにアクセスする場合は以下のようにします。

<pre lang="ruby">
p User.find(1).name # UK
p User.find(1,4)[1].age # 38
p User.find([2])[0].name # hoge
p User.find(:all)[3].name # bar
p User.find(:first).age # UK
</pre>

<h3>ActiveRecord::RecordNotFound</h3>
ちなみに存在しないID(この場合だと5とか)を指定すると例外(ActiveRecord::RecordNotFound)が発生するので注意して下さい。

<h3>条件文の指定</h3>
普通に考えて、データへのアクセスにIDの指定とか不便すぎますよね。次は引数に条件文を与えてみたいと思います。SQLで言う、where文に該当します。

<pre lang="ruby">
p User.find(:first, :conditions => {:name => "UK"})
=> #<user :0x107fa84 @attributes={"name"=>"UK", "id"=>"1", "age"=>"20"}>
p User.find(:first, :conditions => {:name =>"hoge", :age => 40})
=> #</user><user :0x29954ec @attributes={"name"=>"hoge", "id"=>"2", "age"=>"40"}>
p User.find(:first, :conditions => {:name => "aaa"})
=> nil
</user></pre>

条件文は:conditionsで指定します。1番目のfindはnameカラムのデータが"UK"に該当するものから先頭のオブジェクトを返します。ここで:firstの指定を:allに変更すると:conditionsに該当する全てのオブジェクトを配列で返します。

<pre lang="ruby">
User.crate(:name => "UK", :age => 20) # ID = 1と同じデータを保存
p User.find(:fist, :conditions => {:name => "UK"}
=> #<user :0x2980718 @attributes={"name"=>"UK", "id"=>"1", "age"=>"20"}>
p User.find(:all, :conditions => {:name => "UK"}
=> [#</user><user :0x297b45c @attributes={"name"=>"UK", "id"=>"1", "age"=>"20"}>, #</user><user :0x297b614 @attributes={"name"=>"UK", "id"=>"5", "age"=>"20"}>]
</user></pre>

<h3>パラメータによるサニタイズ</h3>
上記のやり方だとパラメータを直接クエリに挿入します。いわゆるサニタイズと言ったものは行っていません。それだと流石にまずいと思うので以下のようにパラメータ使用します。

<pre lang="ruby">
p User.find(:all, :conditions => ["name = ? and age = ?", "UK", 20])
=> [#<user :0x296aa08 @attributes={"name"=>"UK", "id"=>"1", "age"=>"20"}>, #</user><user :0x296abc0 @attributes={"name"=>"UK", "id"=>"5", "age"=>"20"}>]
</user></pre>

このようにしてパラメータを指定することで"UK"と20はサニタイズされます。

<h3>名前付きパラメータ</h3>
パラメータを使用している場合、クエスチョンマークが増えすぎるとわかりにくくなる時があります。その場合は名前つきパラメータを使用します。クエスチョンマークの代わりにシンボルを使用し、シンボルをキーにしたハッシュを渡します。

<pre lang="ruby">
User.find(:all, :conditions => ["name = :name and age = :age", {:name => "UK", :age => 20}])
=> [#<user :0x2962c7c @attributes={"name"=>"UK", "id"=>"1", "age"=>"20"}>, #</user><user :0x2962e34 @attributes={"name"=>"UK", "id"=>"5", "age"=>"20"}>]
</user></pre>

<h2>データの上書き保存</h2>
データの上書き保存(Update)するにはfindメソッドなどでARオブジェクトを作成、操作しsaveメソッドで行ないます。

<pre lang="ruby">
user = User.find(:first, :conditions => {:name => "hoge"})
p user.age # 40
user.age =69
user.save

User.find(:first, :conditions => {:name => "hoge"})
=> [#<user :0x292d694 @attributes={"name"=>"hoge", "id"=>"2", "age"=>"69"}>]
</user></pre>

<h2>データの削除</h2>
データの削除(Delete)はdeleteメソッドや、destroyメソッドを使用します。

<pre lang="ruby">
User.delete(1) # ID = 1を削除

user = User.find(:first, :conditions => {:name => "UK"})
user.destory # name が "UK"のデータを削除
</pre>

<h2>雑感</h2>
とりあえずざっとActiveRecordに触れてみましたが、DBをRubyのオブジェクトのように扱えるのは思いの外気持ちがいいですなー。ただ、プライマリーキー名が"id"固定なところやテーブル名を複数形云々のあたりが気になる人はいるのかなぁと。あと複合キーとかどうするんだーとか。そういうところを気にしないので済むのであれば、ActiveRecordはかなり良いと思います。

それにしてもコードがみづらいことこの上ないですね・・・そのうちなんとかしたいところです。

<a href="http://www.amazon.com/gp/redirect.html%3FASIN=1590598474%26tag=ukstudio0c-22%26lcode=xm2%26cID=2025%26ccmID=165953%26location=/o/ASIN/1590598474%253FSubscriptionId=1N9AHEAQ2F6SVD97BE02" title="Click and drag this image to the post editor"><img src="http://ecx.images-amazon.com/images/I/21rVApqb6cL.jpg" width="121" /></a>
</div></article><div class="pager"><ul><li class="previous"><a href="/page/35/">Prev</a></li><li class="next"><a href="/page/37/">Next</a></li></ul></div></div></body></html>