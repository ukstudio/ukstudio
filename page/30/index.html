<!DOCTYPE html><html><head><meta charset="utf-8" /><!--Always force latest IE rendering engine or request Chrome Frame--><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><!--Use title if it's in the page YAML frontmatter--><title>ukstudio.jp</title><link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css" /><link href="/stylesheets/normalize.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/stylesheets/all.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/stylesheets/highlight.css" media="screen" rel="stylesheet" type="text/css" /><script src="/javascripts/all.js" type="text/javascript"></script><link href="/feed.xml" rel="alternate" title="atom" type="application/atom+xml" /><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-12755601-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></head><body class="page page_30 page_30_index"><div class="cointainer-fluid"><div class="navbar navbar-default" role="navigation"><div class="container-fluid"><div class="navbar-header"><a class="navbar-brand" href="/">UKSTUDIO</a></div><div class="navbar-collapse collapse"><ul class="nav navbar-nav navbar-right"><li><a href="http://twitter.com/ukstudio">Twitter</a></li><li><a href="http://github.com/ukstudio">GitHub</a></li></ul></div></div></div></div><div class="container"><article><h1><a href="/2008/05/27/rawhide-designer/">2008-05-27 RAWHIDE.ではデザイナを募集しています。</a></h1><hr /><div class="article-body">ども、お久しぶりです。久々のエントリで求人ってのも微妙な感じですが、できるだけ色んな人に見てもらいたいですからねー。そもそもこのブログをデザイナが見てるのかどうかが微妙なのかもしれませんが。

そんな感じでどうぞよろしくですよー(0w0)

<a href="http://blog.raw-hide.jp/wp/?p=371">FIGHT! THE RAWHIDE★ &raquo; デザイナー募集のお知らせ</a>

<h3>募集する職種</h3>
<p>
デザイナー　１名
</p>
<h3>仕事内容</h3>
<p>
企画ごとに編成されるチームの一員として、立ち上げから制作、監修までの一連の業務。
※当面は、ディレクション担当者とともに制作進行していただきます。
</p>
<p>
主に平面デザインが主体です。サイトデザイン、ブログパーツデザイン、キャラクターデザイン、など、企画にあがったプロダクト全般のデザインを担当していただきます。
</p>
<p>
FlashオーサリングやHTML+CSSコーディングなどはチームメンバーに担当者がおりますので経験なくとも協力しながら作業をすすめることが可能です。
</p>
<h3>対象となる方</h3>
<p>
専門学校、短大、大学にてグラフィックデザインの教育を受けたデザインの経験者。（アシスタント経験も可）
WEB制作ソフト、グラフィック制作ソフトの知識経験は必須です。
</p>
<h3>ご用意いただくもの</h3>
<ul>
<li>エントリーシート（履歴書・職務経歴書など）</li>
<li>ポートフォリオ（作品集）</li>
</ul>

<h4>ポートフォリオ（作品集）について</h4>
<p>
CD-RかDVDのデータ、または出力書類にてA3サイズまでの封筒で提出してください。
WEBの場合は、URLをエントリーシート内に明記してください。
もしくは画面キャプチャをプリントしてご用意ください。
</p>
<p>
作品については返却しませんので大切なものはコピーなど複製したものをご提出ください。
</p>

<h3>個人情報の取り扱いについて</h3>
<p>応募者情報につきましては、厳重に管理いたします。</p>
<p>
当該個人情報は、採用選考および入社手続きに必要な範囲で利用し、
法令で定められる場合、安全管理処置を講じた委託先に業務委託をする場合をのぞき、
ご本人の同意なく、他の目的では利用することはありません。
</p>
<p>
なお、お送りいただいた各種書類およびデータは、返却いたしませんのでご了承ください。
</p>
<p>
不採用とさせていただいた場合は、選考終了後適切な方法にて破棄いたします。
</p>
</div></article><article><h1><a href="/2008/03/14/autotest_for_macbook/">2008-03-14 MacBookにRailsの自動テスト環境を構築した</a></h1><hr /><div class="article-body">なんかautotestが流行りつつある今日この頃ですが、みなさまいかがお過ごしでしょうか。とりあえず丁度うちの会社でも自動テストしようかーみたいな話がでてたので構築してみましたよ!

<h2>ZenTestのインストール</h2>
とりあえずは定番のZenTest(autotest)とRedGreen(結果の色付け)をインストールします。

<pre lang="bash">
$ sudo gem install ZenTest
$ sudo gem install RedGreen
</pre>

次にautotestの設定ファイルの作成。example_dot_autotest.rbのパスは人によって違うと思うので適当に読み替えてください。

<pre lang="bash">
cp /opt/local/lib/ruby/gems/1.8/gems/ZenTest-3.9.1/example_dot_autotest.rb ~/.autotest
</pre>

~/.autotestの15行目のコメントアウトを解除。

<pre lang="ruby">
require 'autotest/redgreen'
</pre>

RAILS_ROOTでautotestを実行。起動時に全部のテストを実行するのでちょっとだけ重くなるかもしれません。それ以降はテストファイルやモデル、コントローラファイルなどを修正する度に該当のテストが走ります。

<pre lang="bash">
$ cd RAILS_ROOT
$ autotest
</pre>

実行するテストはtest/unit、もしくはRailsにRSpecが入れてあればRspecのテストを実行します。

なんかspec_serverを立ち上げておくと処理が早くなるらしいですがよくわかってないです。まぁとりあえず設定しといて損はなさそうです。

<pre lang="bash">
$ vi spec/spec.opts # 最下行に --drb を追記。drbでテスト用サーバへ繋ぐようになります。
$ ruby script/spec_server
</pre>

テストの結果は成功なら緑色のバーが、失敗なら赤色のバーが表示されます。

<h2>結果通知用にGrowlとScreenの設定をする</h2>

これでも自動テストは走るので問題ないですが、結果を見るのがちょっと面倒ですね。ということでGrowlとScreenで結果が見えるようにしましょう。

screenの場合は<a href="http://kakutani.com/20070912.html#p02">角谷さんのエントリーを</a>見るといいと思います。基本的にそのまま~/.autotestにコピペするだけで問題ないはずです。

<pre lang="ruby">
require 'autotest/screen'   # コメントアウトを外す

Autotest::HOOKS.delete(:interrupt)
Autotest::Screen.statusline = %q[|%c %m/%d|%w %=]

class Autotest::Screen
  SCREEN_COLOR[:green] = 'gw'
  SCREEN_COLOR[:yellow] = 'yk'

  Autotest.add_hook :run_command do |at|
    message 'Running' if execute?
  end

  Autotest.add_hook :quit do |at|
    clear if execute?
  end

  Autotest.add_hook :ran_command do |at|
    return unless execute?
    results = [at.results].flatten.join("¥n")
    output = results.slice(/(¥d+)¥sexamples?,¥s*(¥d+)¥s.*failures?(?:,¥s*(¥d+)¥s.*pendings?)?/)
    if output
      ex,fail,pend = $~.captures.map {|e| e.to_i}
      if 0 < fail
        message "FAIL #{ex}ex, F:#{fail} ", :red
      elsif 0 < pend
        message "Pend #{ex}ex, F:#{fail} P:#{pend}", :yellow
      else
        message "All Green #{ex}ex", :green
      end
    end
  end
end
</pre>

この設定でscreenとautotestを起動しておくと、ステータスバーの右側にテストの結果が表示されます。

<img src="http://img.skitch.com/20080314-d6gq6bsmbbxh99ynx349bfcckf.jpg" alt="autotest"/>

これ貼ってから気づいたけど、Terminalから透けてみえる絵がなんかあれですなw

次にGlowlの設定ですが、Leopardではruby-growlのインストールが必要っぽいです。とりあえずmacportsからインストールしておきましょう。それとGrowlの設定でリモートを許可しておきましょう。

<pre lang="bash">
$ sudo port install ruby-glowl
</pre>

<img src="http://img.skitch.com/20080314-r92e97nip77qfj7u4p2a1ch8e6.jpg" alt="Growl"/>

Growlで結果を通知するにはgrowlnotifyのインストールが必要です。もしインストールしていなければ<a href="http://growl.info/">本家</a>からdmgファイルをDLし、その中にあるinstall.shを実行します。

<pre lang="bash">
$ cp -r /Volumes/Growl\ 1.1.2/Extras/growlnotify ~/tmp
$ cd ~/tmp/growlnotify
$ sudo ./install.sh
$ growlnotify -m "hoge" # growlの通知が表示されればインストール完了
</pre>

~/.autotestを修正し、glowlで結果が通知されるようにします。

<pre lang="ruby">
require 'autotest/glowl' # コメントアウトを解除
</pre>

これでテストが失敗したとき、失敗から成功になったときにGrowlが通知してくれます。Growlの見た目を変更しようと思ったけれど、個人的にscreenだけで十分だったので今回はナシ。

とりあえず自動テストはテストを書くのが楽しくなりますな。オススメ。
</div></article><article><h1><a href="/2008/03/04/from_unittest_to_rspec/">2008-03-04 test/unitで書いたテストにRSpecでテストを追記する方法</a></h1><hr /><div class="article-body">10分ぐらい調べて試してみただけだけど。

<pre lang="ruby">
require 'rubygems'
require 'test/unit'
require 'spec'

class TestArray < Test::Unit::TestCase

  # test/unit
  def test_1
    assert_equal(0, Array.new.size)
  end

  # rspec
  describe Array, "when empty" do
    before do
      @empty_array = []
    end

    it "should be empty" do
      @empty_array.should be_empty
    end

    it "should size 0" do
      @empty_array.size.should == 0
    end

    after do
      @empty_array = nil
    end
  end
end
</pre>

<pre lang="bash">
$ ruby test.rb
....

Finished in 0.007974 seconds

4 examples, 0 failures
</pre>

RSpecの方のテストはるびまの角谷さんの<a href="http://jp.rubyist.net/magazine/?0021-Rspec">記事</a>から拝借しました。

spceをrequireして、クラスに書きこんでいけばよさそう。仕事だとtest/unitで書いてしまったテストも多いだろうから、test/unitからRSpecに移行するのにいいかもしれない。
</div></article><article><h1><a href="/2008/03/01/rawhide/">2008-03-01 RAWHIDE.入社のお知らせ</a></h1><hr /><div class="article-body">こんばんわ、UKです。

実は2月22日に今まで勤務していた会社を退職しました。ついったーやmixiでつながっている人達は知ってたかもですが。

で、新しい職場ですが実は年末から話がすすんでおり(これも一部の人達は知ってたかもですね)、この度3月1日付けで正式にRAWHIDE.に入社することになりました。わーい。

<a href="http://blog.raw-hide.jp/wp/?p=336">FIGHT! THE RAWHIDE★ » RAWHIDE.に入社しました。</a>

早くRAWHIDE.の一員、戦力として役立てるよう頑張る所存です。よろしくお願いします。

<a href="http://twitter.com/Hamachiya2/statuses/742737192">オマケ</a>: こないだ出社したときの話です。ふふふ・・・
</div></article><article><h1><a href="/2008/02/27/haskell_sec3/">2008-02-27 ふつケル第3章</a></h1><hr /><div class="article-body"><h2>型と値</h2>
Haskellには<strong>型推論</strong>という機能がある。型推論は処理系の方で型を推測し、<strong>矛盾なく全ての式が型づけできればコンパイル時にエラーにはならない</strong>。Haskell以外にも、OCaml、Scala、MLなど静的型付け関数型言語のほとんどが型推論の機能を供えている。

Haskellの型には、<strong>Int(整数値)、Char(文字)、String(文字列)、Bool(真偽値)</strong>がある。Intは最低30ビット幅の符号付き整数値を意味する。CharやStringで扱う文字(列)のエンコードにはUnicodeを採用しているが、GHCの実装は中途半端で入出力でのエンコーディング変換などが実装されていない。

また、Int型のリスト、Char型のリストと言う風にリストの型を表現し、Int型のリストの各要素はInt型になる。<strong>ソースコード上では[Int]や[Char]と書く</strong>。文字列は文字のリストなので[Char]ということになり、別名として上記したString型が用意されている。

関数の型をは引数の型と返り値の型を組合せて表現する。例えば、<strong>String -> [String]というのは第1引数の型がString(文字列)で、返り値の型が[String](文字列のリスト)となる</strong>。

<pre lang="haskell">
第1引数の型 -> 第2引数の型 -> ・・・ -> 返り値の型
</pre>

では、引数の型が決まっていない場合どうするのかと言うと、<strong>型変数</strong>と言うものを使う。型変数はアルファベット小文字であらわし、アルファベット小文字の部分は好きな型に読み替えてよい。

<pre lang="haskell">
[a] -> Int
Int -> [a] -> [a]
</pre>

上記の場合だと、1行目は任意の型のリストを引数にもち、Intを返す関数。2行目はIntを第1引数、任意の型のリストを第2引数にもち、第2引数と同じ型のリストを返す関数という意味になる。

<strong>関数の型を宣言</strong>するには、先程関数の型を表現したものに少し付け足せばいい。Haskellは型推論の機能をもつので必ずしも型の宣言が必要というわけではないが、なるべく宣言しておくのが好ましい。

<pre lang="haskell">
関数名 :: 第1引数の型 -> 第2引数の型 -> ・・・ -> 返り値の型
</pre>

<h2>高階関数</h2>
高階関数とは<strong>引数に関数をとる関数</strong>のこと。

<pre lang="haskell">
main = do cs < - getContents
          putStr $ expand cs

expand :: String -> string
expand cs = map translate cs

translate :: Char -> Char
translate c = if c == '\t' then '@' else c
</pre>

このプログラムでは5行目で高階関数のmap関数が使われている。map translate csと言うのは、<strong>translate関数そのものにmapを適用しているのであって、translateの結果にmapを適用しているわけではない</strong>。

mapの型は
<pre lang="haskell">
map :: (a -> b) -> [a] -> [b]
</pre>
となっており、<strong>(a -> b)は「a型の値を引数にとりb型の値を返す関数」</strong>を意味する。今回の場合だと、translate関数の型が Char -> Char となっているので、「Char型の値を引数にとりChar型の値を返す関数」と読み替えることができる。更にいうと(a -> b) -> [a] -> [b] は (Char -> Char) -> [Char] -> [Char]となる。

<pre lang="haskell">
main = do cs < - getContents
          putStr $ expand cs

expand :: String -> String
expand cs = concat $ map expandTab cs

expandTab :: Char -> String
expandTab c = if c == '\t' then "        " else [c]
</pre>

この辺はちょっとややこしくなってくるが、ちゃんと順に考えていけば問題ない。

<h2>パターンマッチ(1)</h2>

<pre lang="haskell">
tabStop = 8

main = do cs < - getContents
          putStr $ expand cs

expand :: String -> String
expand cs = concatMap expandTab cs

expandTab :: Char -> String
expandTab '\t' = replicate tabStop ' '
expandTab c = [c]
</pre>

個人的にtabStopがグローバル変数みたいでなんか気持ち悪い。定数と考えればいいのかな。まぁ今はとりあえず置いておこう。

今回のプログラムの最後2行で<strong>パターンマッチ</strong>を使用している。下から2行目が引数が「\t」の時に使われる定義。最後の行は仮引数が使われているので、「どんな値」にもマッチする。<strong>パターンマッチは上に書いたものが優先され、マッチするパターンが無い場合には実行時にエラーが発生する</strong>。

<pre lang="haskell">
関数名 第1引数のパターン 第2引数のパターン ・・・・ = 定義1
関数名 第1引数のパターン 第2引数のパターン ・・・・ = 定義2
関数名 第1引数のパターン 第2引数のパターン ・・・・ = 定義3
</pre>

<h2>パターンマッチ(2)</h2>
<pre lang="haskell">
map :: (a -> b) -> [a] -> [b]
map f []     = []
map f (x:xs) = f x : map f xs
</pre>

2行目のパターンマッチは空リストに一致する。つまりmapの第2引数が[]だった場合、必ず[]を返すと言うことになる。

3行目の(x:xs)もリストに対するパターンで、空リスト以外のリストにマッチする。<strong>リストの最初の要素がxに束縛され、残りの要素がxsに束縛される</strong>。まぁSchemeのcarやcdrみたいなものかな。

3行目での定義ではまたさらにmapを適用している。つまり、<strong>再帰を用いて処理している</strong>。Haskellには<strong>ループを扱う構文は存在しない</strong>為である。

<pre lang="haskell">
map length ["abc", "de", "f"]
  length "abc" : map length ["de", "f"]
    length "de" : map length ["f"]
      length "f" : map length []
      (1 : [])
    (2 : [1])
  (3:[2,1])
[3, 2, 1]
</pre>

例えば「map length ["abc", "de", "f"」だと多分こんな感じ。<strong>「:」演算子はリストを生成する演算子で(y:ys)ならリストysの先頭に要素yを追加する</strong>。

<h2>練習問題</h2>
<pre lang="haskell">
main = do cs < - getContents
          putStr $ swapa cs

swapa :: String -> String
swapa cs = map replaceA cs

replaceA :: Char -> Char
replaceA 'a' = 'A'
replaceA 'A' = 'a'
replaceA c = c
</pre>

とりあえず動く。

<h2>追記(08/02/27)</h2>
<pre lang="haskell">
main = do cs < - getContents
          putStr $ map swapa cs

swapa :: Char -> Char
swapa 'a' = 'A'
swapa 'A' = 'a'
swapa c = c
</pre>

書き直した。この方が短い。
</div></article><div class="pager"><ul><li class="previous"><a href="/page/29/">Prev</a></li><li class="next"><a href="/page/31/">Next</a></li></ul></div></div></body></html>