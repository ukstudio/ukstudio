<!DOCTYPE html><html><head><meta charset="utf-8" /><!--Always force latest IE rendering engine or request Chrome Frame--><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><!--Use title if it's in the page YAML frontmatter--><title>ukstudio.jp</title><link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css" /><link href="/stylesheets/normalize.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/stylesheets/all.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/stylesheets/highlight.css" media="screen" rel="stylesheet" type="text/css" /><script src="/javascripts/all.js" type="text/javascript"></script><link href="/feed.xml" rel="alternate" title="atom" type="application/atom+xml" /><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-12755601-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></head><body class="page page_38 page_38_index"><div class="cointainer-fluid"><div class="navbar navbar-default" role="navigation"><div class="container-fluid"><div class="navbar-header"><a class="navbar-brand" href="/">UKSTUDIO</a></div><div class="navbar-collapse collapse"><ul class="nav navbar-nav navbar-right"><li><a href="http://twitter.com/ukstudio">Twitter</a></li><li><a href="http://github.com/ukstudio">GitHub</a></li></ul></div></div></div></div><div class="container"><article><h1><a href="/2007/09/05/codeblock/">2007-09-05 コードブロックとyield文</a></h1><hr /><div class="article-body">メソッド内でyield文を使うことでメソッドからコードブロックを呼び出すことができます。yield文が呼び出されるたびに、ブロックに処理が移り、処理が終わるとyieldの直後の処理に移ります。
<pre lang="ruby">def exec_block
  yield
  puts "hoge"
end

exec_block{ puts "Hello,World"}

-----
Hello,Wold
hoge</pre>
ブロックで引数を使いたいときはこんな感じ。yield文に値を与えることでブロックからその値を変数として呼ぶことができます。
<pre lang="ruby">
def exec_block
  yield("foo", 3)
end

exec_block {|str,num| puts str * num}

-----
foofoofoo</pre>
ちなみに当たり前ですが、ブロックはブレース{}でなくても、do endでも問題ありません。１行のブロックの場合にはブレース、複数行の場合にdo endが一般的なようです。

コードブロックを使うとイテレータが実装できますけど、大抵は組み込みのもので事足りるのであまり自分でイテレータを作るっていうのは少ないのかもしれないですね。ま、Rubyの経験が少ないのでよくわかりませんが。
</div></article><article><h1><a href="/2007/08/22/job_change/">2007-08-22 職場を変えようと思います</a></h1><hr /><div class="article-body">一部の人にはちらほら話してますけど、ちょっと職場を変えることを検討してます。できれば今年中には現在の職場に伝えて何らかの就職活動は行いたいところ。

職場を変えようと思った理由は、もっとコードを書きたい、刺激のある職場に行きたいってところですかね。今の職場はあまりプログラミングに専念できる職場じゃないですし、ついったーの人たちの様にWebが好き!プログラミングが好き!って人がいないんですよね。

今の環境が不満なら周りを変えるよう努力してみたら?っていう人もいるかもしれません。けれども僕はそこまでアクティブな人間ではない、むしろ周りに流されがちな人間なわけです。だったら、環境を変えるのも一つの手段なのではないかと思うのです。朱に交われば赤くなるとも言いますし。

じゃあこれからどうするの?と聞かれるとちょっと困ってしまう部分もあるんですよね。なんというか自分の｢売り｣がわからない。少なくとも雇う側としては、中途採用で雇うからには利益を出してもらいたい、つまり即戦力となる人材が欲しいはずなんです。その戦力となる部分が自分にあるのか正直わからない。チンケなプログラムは書けますが、周りを見てるとこれを｢売り｣にするのもおこがましいな、と。

まぁそんなこと言っても、結局は自分がどうしたいかってのが大事だと思うのでそれを踏まえつつ、もう一度自分を見つめ直そうかなと。なにができるんだろう、オレは。とりあえずWebとプログラミングは大好きです。少なくともこれだけはハッキリと言える。これも｢売り｣の一つに入るのかな。

ちなみに特に行きたい会社っていうのはないです。できればRubyを仕事にしてみたいなとは思いますけど。そんなわけでちょっと知り合いに貸してたピッケル本を今日返してもらいました。SICPと並行して読み進めていくつもりです。

実は就職活動とかせずに今の職場に就職したので(アルバイト-&gt;正社員)いまいち職場を変えるにあたってどうしたらいいのかとか、何に気をつけたらいいのかとかわかりません。知り合いの方にはいろいろ相談するかもしれませんが、よろしくお願いします。うちで雇ってもいいよ、っていう人がいらっしゃったら気軽にご連絡くださいw
</div></article><article><h1><a href="/2007/08/09/sicp_002/">2007-08-09 SICP第1章 手続きによる抽象の構築(1)</a></h1><hr /><div class="article-body"><h2>1.1 プログラムの要素</h2>
<dl> <dt>基本式</dt> <dd>言語が関わる最も単純なものを表す</dd> <dt>組合せ法</dt> <dd>より単純なものから合成物を作る</dd> <dt>抽象化法</dt> <dd>合成物に名をつけ、単一のものとして扱う</dd> </dl>
<h3>1.1.1式</h3>
schemeでは前置記法を採用している。慣れるまでが大変かも？
<pre lang="scheme">
(+ 137 349)
;;137 + 349

(+ 21 35 12 7)
;;21 + 35 + 12 + 7

(+ (* 3 5) (- 10 6))
;;(3 * 5) + (10 - 6)</pre>
<h3>1.1.2 組合せの評価</h3>
defineをつかって値と名前の対応付け。いわゆる変数の宣言。

当たり前だけど、値と名前の対応付けを解釈系は記憶している。その記憶のことを(大域)環境という。大域があるなら局所もあるのかな。
<h2>1.1.3 組合せの評価</h2>
<ol> 組合せの評価
	<li>組合せの部分式を評価する</li>
	<li>最左部分式の値である手続き(演算子)を、残りの部分式の値である引数(被演算子)に作用させる</li>
</ol>
<blockquote> すなわち評価の規則は、本質的に再帰的(recursive)である</blockquote>
一般的評価規則の例外を特殊形式(special forms)と言い、defineもそのうちの１つ。
<h3>1.1.4 合成手続き</h3>
合成手続きの作り方。例として二乗を返す合成手続きをサンプルにあげている。基本手続きが変数ならこっちは関数みたいなもの?
<pre lang="scheme">
(define (square x) (* x x))</pre>
<h3>1.1.5 手続き作用の置き換えモデル</h3>
作用的順序と正規順序の違いについて。

<dl> <dt>作用的順序</dt> <dd>引数を評価し、作用させる</dd> <dt>正規的順序</dt> <dd>完全に展開し、簡約する</dd> </dl>通常lispは作用的順序の評価を行うらしい。正規順序は必要になるまで評価を行わないってことだと思うけど、遅延評価って意味なのかな。遅延評価を知らないから何とも言えないけど。
<h3>1.1.6 条件式と述語</h3>
特殊形式「cond」と「if」について。condの方は条件(述語)を複数指定できるけど、ifは1つのみ。他の言語でいうelseifがcondにはあるけど、(schemeの)ifにはelseしかない感じ。

論理演算も使えて、andやor、notがある。andとorは特殊形式で、notは通常の手続き。手続きっていう言葉の意味が自分の中でちょっと曖昧かもしれない。
<h3>問題1.1</h3>
手計算でやって、実際に動かして答え合わせをした。
<h3>問題1.2
<pre lang="scheme">
(/ (+ 5 4) (- 2 (- 3 (+ 6 (/ 4 5)))))(* 3 (- 6 2) (- 2 7)))
;;-37/150</pre>
</h3>
<h3>問題1.3</h3>
<pre lang="scheme">
(define (square x) (* x x))
(define (square_add x y) (+ (square x) (square y)))

(define (ex1_3 x y z)
  (if (&lt; x y)
    (cond ((&lt; x z) (square_add y z))
              (else (square_add x y)))
    (cond ((&lt; y z) (square_add x z))
              (else (square_add x y)))
  )
)</pre>
結構時間かけちゃった。あらかじめsquareとsquare_addを定義してなるべく()を減らす作戦。書き終わった後に気づいたんだけど、最初の分岐はifなのにその次はcondなんだよね。両方ifでいいのにね。
<h3>問題1.4</h3>
問題の意味がうまく汲み取れないけど、多分「Schemeはこんなこともできるんだぜ!すげーだろ!」ってことを言ってるんだと思う。
<pre lang="scheme">
((if (&gt; b 0) + -) a b))
a = 3,b = -2
(- 3 -2) -&gt; 5
a = 3, b = 2
(+ 3 2) -&gt; 5</pre>
引数の値によって手続きも変えられるってことかな。
<h3>問題1.5</h3>
これも結構理解できるまで時間がかかった。

作用的順序の場合(test 0 (p))で先に(p)を評価する。けれど(p)の評価した時の結果が(p)だから無限ループになる。
<pre lang="scheme">
(test 0 (p))
(p)を先に評価
(test 0 (p))
以降繰り返し...</pre>
正規順序の場合は、(p)を評価するのは後回しにするから無限ループにはならないで済む
<pre lang="scheme">
(test 0 (p))
(if( (= 0 0)) 0 p))
(= 0 0)が#tだから0を返す</pre>
</div></article><article><h1><a href="/2007/08/03/sicp_001/">2007-08-03 いい加減SICPを読み始めることにした</a></h1><hr /><div class="article-body"><h2>宣言</h2>
いつ買ったのかわからないSICPをいい加減読むことにしました。どっかで宣言しないといつまでもやらなそうなので、エントリーで宣言して無理にでもやろうという魂胆。一応、成果はブログで書いていくつもりなので更新なかったら「さっさと読めよ、カス」って言ってやってください。

<h2>読もうとおもった理由</h2>
<ul>
	<li>個人的にすごいなって思う人は大抵SICPを読んでるっぽい</li>
	<li> 再帰とかクロージャとかよくわからない</li>
	<li>プログラミングの基礎がない</li>
	<li>schemeに興味がある</li>
	<li>若いうちに読んどくべきな気がする</li>
</ul>
まぁ、SICPを読み切ったら精神と時の部屋を出た後の悟空みたいに別人になれるんじゃねーかっていうそんな淡い期待を持ってるわけです。
<h2>ルール</h2>
<ul>
<li>1ページでも数行でもいいから毎日読む</li>
<li>わからなくても泣かない</li>
<li>練習問題はちゃんと解く</li>
<li>成果はブログでアウトプット</li>
</ul>
<h2>環境の用意</h2>
環境はMacBookなのでMacPortsでGaucheをインストールすることにしました。
<pre>
sudo port install gauche
</pre>
</div></article><article><h1><a href="/2007/07/16/070714_js/">2007-07-16 初心者向けJavaScript勉強会の資料公開と補足</a></h1><hr /><div class="article-body">とある理由で僕主催の初心者向けのJavaScript勉強会 を14日行いました。とある理由はforestkさんのエントリーを参照ください(<a href="http://blog.livedoor.jp/forestk/archives/50357381.html">UK 主催の初心者向け Javascript 勉強会が生まれた経緯</a>)

会場は<a href="http://www.knocking.co.jp/">株式会社ノッキングオン</a>様にご提供いただきました。借りたい人ははてなキーワードの<a href="http://d.hatena.ne.jp/keyword/%A5%CE%A5%C3%A5%AD%A5%F3%A5%B0%A5%AA%A5%F3%A4%CE%B2%F1%B5%C4%BC%BC%BB%C8%A4%A4%A4%BF%A4%A4%21">ノッキングオンの会議室使いたい!</a>を利用するといいと思います。東麻布でプロジェクター &amp; ネット環境あり(優先ですがアクセスポイントを持参すれば無線も利用可能みたいです)の好環境ですのでかなりおすすめの物件となっております:-P

資料を公開しますので参考になれば幸いです。といっても、ほとんど入門書に書いてあるようなことですがwしかもif文とかの説明すげー適当だしね!

資料URL : <a href="http://www.slideshare.net/ukstudio/javascript/11">http://www.slideshare.net/ukstudio/javascript/11</a>

質問されたり、資料が半端な出来だったりしたのでちょっといくつか補足しておきます
<h2>補足1:連想配列とオブジェクト</h2>
連想配列とオブジェクトの違いはなにか?みたいな質問を受けたので簡単にお答えします。結論としてその２つに<strong>違いはない</strong>と僕は考えます。下のコードをみてください。
<pre lang="javascript">
var obj = {
  name : "UK",
  age : 20,
  birthday : "12月14日"
}

alert(obj.name);       //UK
alert(obj["name"]); //UK</pre>
1つ目のalertは資料でも説明したプロパティの呼び出しです。2つ目に注目してください。連想配列と同じ呼び出し方をしてますよね。今度は次のコードをみてください。
<pre lang="javascript">
var array = new Array();
array["name"] = "UK";
array["age"] = 20;
array["birthday"] = "12月14日";
alert(array["name"]);  //UK
alert(array.name);        //UK</pre>
上記のように連想配列でもドットシンタックス(.)を使って値を呼び出すことができます。これでなんとなくは連想配列とオブジェクトに違いはないと言った意味がわかってもらえたんじゃないでしょーか。

結局は連想配列もオブジェクトの一種(Arrayオブジェクト)なので元をたどっていけばもっとも基本的なオブジェクト(Objectオブジェクト)に行き着くってことです。これはArrayオブジェクトに限らず他のオブジェクト(DateオブジェクトとかFunctionオブジェクトとか)も最終的にはObjectオブジェクトに行き着きます。Objectオブジェクトがすべてのオブジェクトの出発点なのです。

ちょっとおまけですが、連想配列ではなく普通の配列を空のオブジェクトから作ってみます。
<pre lang="javascript">
var array = {
  0 : "インデックス0",
  1 : "インデックス1",
  2 : "インデックス2"
}

alert(array[0]);     //インデックス0
alert(array.0);           //エラー</pre>
とまぁ、こんな感じでプロパティのラベルに数値でつけてやれば配列のようなオブジェクトができます。あとはlengthプロパティだとかをつけてやればOKですね(どうやってプロパティの数を求めるんだとかは聞かないでね)

ただ、自分もちょっとよくわかってない点がarray.0でエラーがでるところですね。多分、0がプリミティブな数値リテラルとして扱われてるからかなとか思うんですがなんともかんとも。
<h2>補足2:数値オブジェクトと文字列オブジェクト</h2>
資料で数値も文字列もオブジェクトと書いてありますが厳密には違います。口頭で簡単に説明しましたがちゃんと文章で補足しておきます

文字列や数値にドットシンタックスをつけると一時的にプリミティブなリテラルからオブジェクトに変換されます。だからプロパティやメソッドを呼び出せるようになるわけです。あくまで<strong>変換</strong>なので厳密にはオブジェクトではない、ということです。
<h2>補足3:yoshioriさんのクイズ</h2>
<a href="http://yoshiori.org/blog/">yoshiori</a>さんのクイズで下のようなクイズがあったと思います。非プログラマな方にはいまいちわからない部分があったと思うので簡単に解説します。ちなみにswitch文とか他の問題は自分も理解があやふやなのでスルーです。
<pre lang="javascript">
alert(2 &amp; 3 == 1);    //0</pre>
まず各演算子には優先順位というものが存在します。(後で説明します)&amp;と==では==の方が優先順位が高いので3==1が先に評価され、falseが返されます。

falseというのは真偽値でいう偽の値でつまりは｢0｣です。そうすると2 &amp; 0のビット演算が行われ0が返されるという訳です。

とか言っても、ビット演算がわからないと思うのでそこを説明したいと思います。

ビット演算は2進数で計算されます。2進数っていうのは10進数が10で次の桁に繰り上がるように2で次の桁に繰り上がります。つまり0と1で表現します。

2を二進数で表すと0010になります。0は当然0000ですね。これを&amp;演算します。
<pre>
 0010
&amp;0000
------
 0000</pre>
&amp;演算というのは両方が1のときだけ1を返す演算です。今回は片方が0なので問答無用で全部0を返すということです。

ちなみにalert(7 &amp; 3)とかだったら3を返します。
<pre>
 0111
&amp;0011
---------
0011 = 3</pre>
ビット演算はあまり使う機会はないと思いますが、興味ある人は調べてみるといいと思います。
<h2>補足4:演算子の優先順位</h2>
上でちょろっと言いましたが、演算子には優先順位というものが存在します。簡単な例を出してみます。
<pre lang="javascript">
var a = 100 + 200 * 10;alert(a); // 2100</pre>
aの宣言のところで演算子は = , + , *の３つがあります。この３つでの優先順位は * &gt; + &gt; = のようになります。

* と + は数学と同じですからわかりやすいと思います。=が低いのは単純に計算が終わる前に値を代入しちゃうのはまずいよね?ってことです。

上の式を頭で計算するときもまずは200 * 10して2000を求めます。そしたら100  + 2000で2100が得られるので最後にa= 2100しますよね。それと同じことです。

他にも多種多様な演算子があってそれぞれ優先順位があります。さらに小難しい話をすると演算子の結合性といった話もでてきます。そこまで説明するのはちょっと骨が折れるので割愛しますが、なんとなくは演算子の優先順位といったものがわかっていただけると幸いです。
<h2>まとめ</h2>
かなり長いエントリーになってしまい申し訳ないです。本当はもうちょっとDOMまわりの補足もしたかったんですが、それはまた別の機会にお話するかエントリーをあげたいと思います。

今回の勉強会は参加する側ではなく主催するという僕にとっては初の試みでしたが、無事(?) になんとか終えることができました。様々な方にご協力いただき本当にありがとうございます。

第２回目希望の声もちらほらと聞こえており、うれしい限りです。もし次も発表する側であれば、ちゃんと準備して本番に望みたいと思います( 前日に資料作るとかあほだよねw)

追記

発表する側に立ってみて思ったことですが、あらためてアウトプットは大事だなと。本を読んだり、話を聞くよりも何倍も勉強になった気がします。デザイン勉強会の話もでてるみたいなので、もし発表するか迷ってる人はとりあえずやってみることをおすすめします。いろいろ不安もあると思いますが、みんないい人なのでなんとかなります、きっとw

あ、あと全体のまとめはちょっと書ききれなかったので<a href="http://www.hamashun.com/blog/2007/07/javascript.html">hamashun</a>さんのブログをみるよーに。
</div></article><div class="pager"><ul><li class="previous"><a href="/page/37/">Prev</a></li><li class="next"><a href="/page/39/">Next</a></li></ul></div></div></body></html>