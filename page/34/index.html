<!DOCTYPE html><html><head><meta charset="utf-8" /><!--Always force latest IE rendering engine or request Chrome Frame--><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><!--Use title if it's in the page YAML frontmatter--><title>ukstudio.jp</title><link href="http://fonts.googleapis.com/css?family=Inconsolata" rel="stylesheet" type="text/css" /><link href="/stylesheets/normalize.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/stylesheets/all.css" media="screen" rel="stylesheet" type="text/css" />
<link href="/stylesheets/highlight.css" media="screen" rel="stylesheet" type="text/css" /><script src="/javascripts/all.js" type="text/javascript"></script><link href="/feed.xml" rel="alternate" title="atom" type="application/atom+xml" /><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-12755601-1']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></head><body class="page page_34 page_34_index"><div class="cointainer-fluid"><div class="navbar navbar-default" role="navigation"><div class="container-fluid"><div class="navbar-header"><a class="navbar-brand" href="/">UKSTUDIO</a></div><div class="navbar-collapse collapse"><ul class="nav navbar-nav navbar-right"><li><a href="http://twitter.com/ukstudio">Twitter</a></li><li><a href="http://github.com/ukstudio">GitHub</a></li></ul></div></div></div></div><div class="container"><article><h1><a href="/2007/12/20/fixdap_ruby_project/">2007-12-20 fixdap.jpに「Rubyを極める」プロジェクトを作ってみました</a></h1><hr /><div class="article-body"><a href="http://fixdap.com/p/Ruby/">Rubyを極める - fixdap</a>

@mobcovが<a href="http://fixdap.com/p/RubyCocoa/">RubyCocoaを極める - fixdap</a>を。@faultierが<a href="http://fixdap.com/p/rspec/">RSpecを極める - fixdap</a>を作っていたので、それらの姉妹プロジェクトってことで。

とりあえず、あまり難しいことは考えてないので「こんな勉強をしてみよう」とか「Rubyで○○なプログラムを書いてみよう」とかちょっとしたことでもタスク作っちゃって欲しいなと思う今日この頃。

丁度、近いうちに「たのしいRuby 第2版」の練習問題をちゃんとやろうと思ってたのでそのタスクを作ってみた。(<a href="http://fixdap.com/p/Ruby/1760/">http://fixdap.com/p/Ruby/1760/</a>)書いたプログラムはこのブログにでも貼りつけて、そのリンクをfixdapの方にコメントで書けばいいかな。

もしくは、CodeReposにCommitしちゃうってのもありかなー。/lang/ruby/study/tanoshi_ruby/とかで。んで、もし添削したい人とかいたら勝手に修正してCommitしちゃえばいいし。あまりにも書き直すようであれば、fixdapのコメントで一言言うか、気にせずCommitして、svnのコメントになんかしら書いておけばいいし。

プロジェクトメンバーがオレ１人なのが寂しいなー。作ったばかりだから仕方ないけどw

<h2>追記 07/12/20</h2>
yappoさんからブクマでコメントもらいました。
<blockquote>
yappo coderepos 添削用は coderepos.org/share/dan 以下で
</blockquote>
とのことなので、coderepos.org/share/dan/ruby/tanoshi_ruby/とか作ろうと思います。yappoさん、ありがとう。

あとプロジェクトメンバーがちょこっと増えてた。わっほい。
</div></article><article><h1><a href="/2007/12/05/install_retrospectiva/">2007-12-05 RetrospectivaをMacBookに設置してみた</a></h1><hr /><div class="article-body"><a href="http://retrospectiva.org/blog">blog . retrospectiva</a>

どんなものか試しに設置してみた。あくまで試しなのでSQLite、WEBrickで。まずは必要なソフトのインストールから。

<h2>SQLite3のインストール</h2>
MacPortsを使ってSQLiteを、RubyGemsを使ってSQLiteを扱うライブラリをインストール。
<pre lang="bash">
% sudo port install sqlite3
% sudo gem install sqlite3-ruby
</pre>

<h2>retrospectivaの設置</h2>
<a href="http://retrospectiva.org/wiki/Quick+install">Quick Install - wiki . retrospectiva</a>を参考にしつつ。

<pre lang="bash">
% svn export http://retrospectiva.googlecode.com/svn/branches/1-0 retrospectiva
% cd restrospectiva
</pre>

リポジトリからファイルを持ってきたら、DBの設定がMySQLになっているのでSQLiteの設定に変更。
<pre lang="bash">
% mv config/database.yml.todo config/database.yml
% vim config/database.yml
</pre>
<strong>database.yml</strong>
<pre lang="ruby">
development:
  adapter: sqlite3
  database: retrospectiva_development

test:
  adapter: sqlite3
  database: retrospectiva_test

production:
  adapter: sqlite3
  database: retrospectiva
</pre>

rakeは試しなのでdevelopment(引数なし)で。特にエラーがでないようならWEBRickを起動してhttp://localhost:3000/にアクセス。

<pre lang="bash">
% rake db:retro:load
% ruby script/server
</pre>

IDとパスワードを聞かれるので admin / passwordを入力。

適当にプロジェクトを作ってみた感じが以下のキャプチャ。
<img src="http://farm3.static.flickr.com/2067/2086299815_6a6030a3b6.jpg?v=0"/>

SVNの連携とかはまたそのうち。Rails環境があれば、とりあえず起動するのはラクチン。
</div></article><article><h1><a href="/2007/12/05/ruby_array_operator/">2007-12-05 RubyのArrayの演算子はちょっとおもしろい</a></h1><hr /><div class="article-body">Arrayの「+」「-」「&」「|」演算子がちょっとおもしろい。
<h2>+演算子</h2>
お互いを連結した新しい配列を返す。
<pre lang="ruby">
[1, 2, 3] + [4, 5, 6] #=> [1, 2, 3, 4, 5, 6]
</pre>

<h2>-演算子</h2>
重複した要素を取り除いた新しい配列を返す。
<pre lang="ruby">
[1, 2, 3, 4, 5] - [1, 3, 5] #=> [2, 4]
</pre>

<h2>&演算子</h2>
重複した要素からなる新しい配列を返す。
<pre lang="ruby">
[1, 2, 3, 4, 5] & [1, 3, 5] #=> [1, 3, 5]
</pre>

<h2>|演算子</h2>
どちらかに含まれている要素からなる新しい配列を返す。
<pre lang="ruby">
[1, 2, 3, 4, 5] | [1, 3, 5, 7, 9] #=> [1, 2, 3, 4, 5, 7, 9]
[1, 3, 5] | [1, 2, 3, 4, 5] #=> [1, 3, 5, 2, 4]
</pre>
</div></article><article><h1><a href="/2007/12/01/ruby_rpn_ujihisa_sixeight/">2007-12-01 後置記法のコードを添削してもらっちゃいました</a></h1><hr /><div class="article-body"><a href="http://ujihisa.nowa.jp/entry/60c2b3fcf9">rubyneko - Re: UK STUDIO 後置記法での計算</a>
<a href="http://d.hatena.ne.jp/Sixeight/20071130/1196438912">後置記法での計算の添削に便乗してみた - チナミニ</a>

ujihisaさんとSixeightさんには感謝です。せっかくなんで添削してもらったコードを自分なりにちゃんと理解しときたいと思います。

<h2>ujihisaさんのコード</h2>

<pre lang="ruby">
class String
  def rpn
    expr = self.split(" ")
    stack = []
    operators = %w[+ - * /]

    expr.each do |i|
      if operators.include? i
        stack = [calc(i, stack)]
      else
        stack < < i.to_i
      end
    end

    stack[0]
  end

  private
  def calc(operator, stack)
    stack.inject {|result, i|
      result.__send__(operator, i)
    }
  end
end
</pre>
<h3>stackに文字列でなく数値を格納していく</h3>
確かに所々でto_i使い過ぎだ。これだけで全然スッキリするなぁ・・・
<h3>スコープは狭く</h3>
ですよねぇ。なんでクラス変数にしたんだろう、おれは。猛省。
<h3>Array.newを[]に</h3>
個人的にはなんかArray.newがしっくりくるんですよね。「Arrayをnewする」みたいな感じで。[]だとあまりそんな感じがしない。

まぁ慣れの問題な気もするので、[]も使っていこうと思います。

<h3>returnは省略</h3>
これはなんか個人的には解決してない問題でして。値を返すことを強調したいときはreturnをつけようとか思っていたんだけど。

ただ、Rubyは必ず値が返ってくることを考えると、やっぱり基本的に省略なのかなぁ。

ちなみにTwitterでぼそっとぼやいたらこんな反応が。
<ul>
<li><a href="http://twitter.com/yuki_neko_nyan/statuses/456843452">http://twitter.com/yuki_neko_nyan/statuses/456843452</a></li>
<li><a href="http://twitter.com/natsutan/statuses/456852982">http://twitter.com/natsutan/statuses/456852982</a></li>
</ul>

<h3>Array(...)を[...]に</h3>
[]で囲むのでもいいのか。知らなかった。

<h3>calcがArrayを返すより、stackに入れるときにArrayにするべし</h3>
説明がなんかHaskellerっぽいですな。

calc::char->[int]->[int]ってどう言う意味だっけ。確か、第1引数の型->第2引数の型->返り値の型だったかな。[int]はintの配列ってことかな・・・

確かにcalcの処理内容を考えると[int]よりintの方がわかりやすいな。ふむ。

<h3> eachのブロックを{}からdo endに</h3>
そもそも、自分のコーディング規約を守ってない件。複数行のブロックはdo...end使うって決めたのに!

<q>副作用を目的としているケースでは、こちらのが直感的</q>とあるけど、何故だかちょっとわからない。直感的ってのもまた人それぞれな部分あるしなぁ。

<h3>if i == "+" || i == "-" || i == "*" || i == "/"をArray#include?を使ってシンプルにまとめた</h3>
このifは自分でも汚いなとは思ってた。各演算子を配列にまとめてinclude?で判断か。ブロック引数iの値が配列に含まれていればtrueを返すから、この場合だと"+", "-", "*", "/"のどれかだとtrueになると。

<h3>calcについて</h3>
</pre><pre lang="ruby">
result.__send__(operator, i)
</pre>
って記述を見たとき、「あれ、resultに代入しなくていいの?」とか思ったんだけど、ちゃんと調べてみると途中のブロックの返り値は次の呼び出しの時にresultに渡されるんだとさ。ちゃんと調べろよって話ですね。


ujihisaさんにはさらに短かくしたコードも書いてもらってるんだけどまだちょっと追えてない。これはまた後日こっそり調べとく。

<h2>Sixeightさんのコード</h2>
関係ないけどSixeightさんってtyoroの後輩だっけ?

<pre lang="ruby">
class String
  # Reverse Polish Notation
  # '4 5 +'.rpn => 4 + 5 = 9
  def rpn
    stack = []
    opr = %q[ + - * / ]

    split(' ').each do |i|
      if opr.include? i
        stack[-1] = stack[-2].__send__(i, stack.pop)
      else
        stack < < i.to_i
      end
    end
    stack.first
  end
end
</pre>
一応、最終的なコードを見せてもらう。(もちろん、その前のコードも読みましたよ)全体的にSixeightさんもujihisaさんのコードを見たあとのせいか、基本的には上で書いたことと同じ感じかなー。

ただ、演算の処理をメソッドで別にせず1行で済ませてますな。あとオレの場合はめんどくさくて、stackを全部上書きしちゃってるけど、Sixeightさんはpopで取り出してちゃんと処理してる。

個人的にはstack[-1]とstack[-2]が気になるかな。インデックスの-が個人的に好きじゃないようで。まぁあんなcalcメソッド書いといて何言ってるんだって感じですよね。すみません。

逆ポーランド記法の仕様についてはあまりちゃんと調べてなかったり。なんかSchemeの前置記法と似た感覚で複数の値も計算するもんだと思ってたけど違うのかな。

<h3>追記</h3>
はてブにSixeightさんのコメントが!
<blockquote>
インデックスの-は僕も否定派なんですが、スタックから取り出す順番をひっくり返すのが思い浮かばなくて＞＜精進しなきゃ
</blockquote>
やっぱ-は否定的なのかー。お互いがんばりまっしょい。

<h2>書き直したコード</h2>
</pre><pre lang="ruby">
class String
  def rpn
    expr = self.split(" ")
    stack = []
    operators = %w[+ - * /]

    expr.each do |i|
      if operators.include? i
        stack = [stack.inject{|result, item| result.__send__(i, item)}]
      else
        stack < < i.to_i
      end
    end

    stack.first
  end
end
</pre>
ujihisaさんのコードをほとんど反映させた感じ。例外処理とか考えてないよ。あとスタックにある数値も全部計算する仕様のまま。</pre>
</div></article><article><h1><a href="/2007/11/29/ruby_rpn/">2007-11-29 後置記法での計算</a></h1><hr /><div class="article-body"><a href="http://ja.wikipedia.org/wiki/逆ポーランド記法">後置記法</a>の文字列を計算するようStringクラスを拡張してみた。
<strong>rpn.rb</strong>
<pre lang="ruby">
class String
  def rpn
    @expr = self.split(" ")
    stack = Array.new

    @expr.each {|i|
      if i == "+" || i == "-" || i == "*" || i == "/"
        stack = calc(i, stack)
      else
        stack < < i
      end
    }

    return stack[0]
  end

  private
  def calc(operator, stack)
    return Array(stack[1..-1].inject(stack[0].to_i){|result, i|
      reslut = result.__send__(operator, i.to_i)
    })
  end
end
</pre>
</pre><pre lang="ruby">
require 'rpn.rb'
"2 8 +".rpn #=> 10
"4 6 -".rpn #=> -2
"81 9 /".rpn #=> 9
"4 3 *".rpn => 12
"3 7 + 10 20 + 2 * 10 + 80 -".rpn
#=>10
</pre>
入力は文字列で返り値が数値なのが違和感あるかもしれないけど、String#hexもそんな感じだし別にいいかなと。

最初はモジュールにして、それをStringクラスにincludeしようとか思ってたんだけど、モジュールにするとselfで自身の文字列を取得する方法がわからなくて断念。モジュールのselfだとモジュール自身を指しちゃうんだよね。

あとはcalcメソッドの中がなんか汚いのも気になるなぁ。

全然関係ないけど、後置記法よりSchemeみたいな前置記法の方がわかりやすいと思った。
</div></article><div class="pager"><ul><li class="previous"><a href="/page/33/">Prev</a></li><li class="next"><a href="/page/35/">Next</a></li></ul></div></div></body></html>