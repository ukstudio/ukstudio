{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts//2007/10/28/activerecord/","result":{"data":{"site":{"siteMetadata":{"title":"UKSTUDIO BLOG"}},"markdownRemark":{"id":"fdbd5936-2332-5fa3-9266-9f586e630578","excerpt":"ActiveRecordはRubyOnRailsのO/Rマッパーとして有名ですが、Railsに依存しているわけではなく単体で使えます。 ユーザ名と年齢を管理するテーブルってことで。 データベースへのコネクションはActiveRecord::Base.establish_connection…","html":"<p>ActiveRecordはRubyOnRailsのO/Rマッパーとして有名ですが、Railsに依存しているわけではなく単体で使えます。</p>\n<h2>DBを用意する</h2>\nなにはともあれ、DBがないと始まらないので適当に用意します。\n<pre lang=\"sql\">create database ar;\n use ar;\n create table users (\n   id int unsigned not null auto_increment,\n   name varchar(50),\n   age int,\n   primary key (id)\n );\n</pre>\n<p>ユーザ名と年齢を管理するテーブルってことで。</p>\n<h2>DBへの接続とマッピング</h2>\n<pre lang=\"ruby\">\nrequire 'rubygems'\nrequire_gem 'activerecord'\n\n# ARで接続\nActiveRecord::Base.establish_connection(\n  :adapter    =>      'mysql',\n  :host       =>      'localhost',\n  :username   =>      'ユーザ名',\n  :password   =>      'パスワード',\n  :database   =>      'ar',\n  :socket     =>      '/tmp/mysql.sock'\n)\n\n# マッピングクラスを定義\nclass User < ActiveRecord::Base\nend\n</pre>\n<p>データベースへのコネクションはActiveRecord::Base.establish_connectionで作られます。特にむずかしいところはないですね。socketは必ず書く必要はないです。書かない場合は/tmp/mysql.sockを見にいくのかな。</p>\n<p>ActiveRecord::Baseを継承することでマッピングクラスを定義することができます。クラス名がUserusersテーブルへのマッピングを定義していることになります。クラスを単数形、テーブル名を複数形にすることで自動的にマッピングされます。いわゆるCoC(Convention over Configuration)ってやつです。</p>\n<h2>データの保存</h2>\nnewメソッド、もしくはcreateメソッドを使用し、ARオブジェクトを作成することでDBにデータを保存(Insert)することができます。newとcreateの違いは、newは明示的にsaveメソッドを実行する必要があり、createは自動的にsaveメソッドも実行されます。\n</pre><pre lang=\"ruby\">\n# ARオブジェクトを作成\nuser = User.new(:name => \"UK\", :age => 20)\nuser.save    # DBに格納\n</pre>\n<pre lang=\"ruby\">\n# ARオブジェクトを作成\nuser = User.create(:name => \"UK\", :age =>20) # この時点でDBに格納される\n</pre>\n<img src=\"http://farm3.static.flickr.com/2121/1590439456_c3203f167b.jpg?v=0\">\n<h2>&#x30C7;&#x30FC;&#x30BF;&#x306E;&#x691C;&#x7D22;</h2>\n<img src=\"http://farm3.static.flickr.com/2137/1786644895_9bfe2b148c.jpg?v=0\">\n&#x30C7;&#x30FC;&#x30BF;&#x304C;1&#x4EF6;&#x3060;&#x3051;&#x3058;&#x3083;&#x5C11;&#x306A;&#x3044;&#x306E;&#x3067;&#x6570;&#x4EF6;&#x307B;&#x3069;&#x8FFD;&#x52A0;&#x3057;&#x307E;&#x3057;&#x305F;&#x3002;\n<p>データの検索(Select)にはfindメソッドを使用します。他にもfind<em>allとか、find</em>by<em>sqlとかあるけどとりあえずfindのみの説明で。ちなみにfind</em>allは非推奨的な雰囲気。find(:all)を使えってことですね。</p>\n<blockquote>\nDEPRECATION WARNING: find_all is deprecated and will be removed from Rails 2.0 ( use find(:all, ...)) See http://www.rubyonrails.org/deprecation for details.\n</blockquote>\n<h3>findメソッド</h3>\nfindメソッドの引数にIDを指定することで、該当するデータのオブジェクトが得られます。IDは複数指定することが可能でその場合の戻り値は配列です。:allを指定すると、 全件分のオブジェクトが得られます。こちらの場合も配列です。:firstを指定すると、先頭のオブジェクトを得られます。\n<pre lang=\"ruby\">\np User.find(1) # ID = 1のオブジェクト\n=> #<user :0x147fbe8 @attributes={\"name\"=>\"UK\", \"id\"=>\"1\", \"age\"=>\"20\"}>\np User.find(1,4) # ID =1, ID = 4 のオブジェクトを格納した配列\n=> [#</user><user :0x1476ed0 @attributes={\"name\"=>\"UK\", \"id\"=>\"1\", \"age\"=>\"20\"}>,\n #</user><user :0x147709c @attributes={\"name\"=>\"bar\", \"id\"=>\"4\", \"age\"=>\"38\"}>]\np User.find([2]) # ID = 2のオブジェクトを格納した配列\n=> [#</user><user :0x14711d8 @attributes={\"name\"=>\"hoge\", \"id\"=>\"2\", \"age\"=>\"40\"}>]\np User.find(:all) # 全件分のオブジェクトを格納した配列\n=> [#</user><user :0x140fca8 @attributes={\"name\"=>\"UK\", \"id\"=>\"1\", \"age\"=>\"20\"}>, #</user><user :0x140fc94 @attributes={\"name\"=>\"hoge\", \"id\"=>\"2\", \"age\"=>\"40\"}>, #</user><user :0x140fc6c @attributes={\"name\"=>\"foo\", \"id\"=>\"3\", \"age\"=>\"14\"}>, #</user><user :0x140fc44 @attributes={\"name\"=>\"bar\", \"id\"=>\"4\", \"age\"=>\"38\"}>]\np User.find(:first) # 先頭のオブジェクト\n=> #</user><user :0x140cd28 @attributes={\"name\"=>\"UK\", \"id\"=>\"1\", \"age\"=>\"20\"}>\n</user></pre>\n<p>各カラムのデータにアクセスする場合は以下のようにします。</p>\n<pre lang=\"ruby\">\np User.find(1).name # UK\np User.find(1,4)[1].age # 38\np User.find([2])[0].name # hoge\np User.find(:all)[3].name # bar\np User.find(:first).age # UK\n</pre>\n<h3>ActiveRecord::RecordNotFound</h3>\nちなみに存在しないID(この場合だと5とか)を指定すると例外(ActiveRecord::RecordNotFound)が発生するので注意して下さい。\n<h3>条件文の指定</h3>\n普通に考えて、データへのアクセスにIDの指定とか不便すぎますよね。次は引数に条件文を与えてみたいと思います。SQLで言う、where文に該当します。\n<pre lang=\"ruby\">\np User.find(:first, :conditions => {:name => \"UK\"})\n=> #<user :0x107fa84 @attributes={\"name\"=>\"UK\", \"id\"=>\"1\", \"age\"=>\"20\"}>\np User.find(:first, :conditions => {:name =>\"hoge\", :age => 40})\n=> #</user><user :0x29954ec @attributes={\"name\"=>\"hoge\", \"id\"=>\"2\", \"age\"=>\"40\"}>\np User.find(:first, :conditions => {:name => \"aaa\"})\n=> nil\n</user></pre>\n<p>条件文は:conditionsで指定します。1番目のfindはnameカラムのデータが”UK”に該当するものから先頭のオブジェクトを返します。ここで:firstの指定を:allに変更すると:conditionsに該当する全てのオブジェクトを配列で返します。</p>\n<pre lang=\"ruby\">\nUser.crate(:name => \"UK\", :age => 20) # ID = 1と同じデータを保存\np User.find(:fist, :conditions => {:name => \"UK\"}\n=> #<user :0x2980718 @attributes={\"name\"=>\"UK\", \"id\"=>\"1\", \"age\"=>\"20\"}>\np User.find(:all, :conditions => {:name => \"UK\"}\n=> [#</user><user :0x297b45c @attributes={\"name\"=>\"UK\", \"id\"=>\"1\", \"age\"=>\"20\"}>, #</user><user :0x297b614 @attributes={\"name\"=>\"UK\", \"id\"=>\"5\", \"age\"=>\"20\"}>]\n</user></pre>\n<h3>パラメータによるサニタイズ</h3>\n上記のやり方だとパラメータを直接クエリに挿入します。いわゆるサニタイズと言ったものは行っていません。それだと流石にまずいと思うので以下のようにパラメータ使用します。\n<pre lang=\"ruby\">\np User.find(:all, :conditions => [\"name = ? and age = ?\", \"UK\", 20])\n=> [#<user :0x296aa08 @attributes={\"name\"=>\"UK\", \"id\"=>\"1\", \"age\"=>\"20\"}>, #</user><user :0x296abc0 @attributes={\"name\"=>\"UK\", \"id\"=>\"5\", \"age\"=>\"20\"}>]\n</user></pre>\n<p>このようにしてパラメータを指定することで”UK”と20はサニタイズされます。</p>\n<h3>名前付きパラメータ</h3>\nパラメータを使用している場合、クエスチョンマークが増えすぎるとわかりにくくなる時があります。その場合は名前つきパラメータを使用します。クエスチョンマークの代わりにシンボルを使用し、シンボルをキーにしたハッシュを渡します。\n<pre lang=\"ruby\">\nUser.find(:all, :conditions => [\"name = :name and age = :age\", {:name => \"UK\", :age => 20}])\n=> [#<user :0x2962c7c @attributes={\"name\"=>\"UK\", \"id\"=>\"1\", \"age\"=>\"20\"}>, #</user><user :0x2962e34 @attributes={\"name\"=>\"UK\", \"id\"=>\"5\", \"age\"=>\"20\"}>]\n</user></pre>\n<h2>データの上書き保存</h2>\nデータの上書き保存(Update)するにはfindメソッドなどでARオブジェクトを作成、操作しsaveメソッドで行ないます。\n<pre lang=\"ruby\">\nuser = User.find(:first, :conditions => {:name => \"hoge\"})\np user.age # 40\nuser.age =69\nuser.save\n\nUser.find(:first, :conditions => {:name => \"hoge\"})\n=> [#<user :0x292d694 @attributes={\"name\"=>\"hoge\", \"id\"=>\"2\", \"age\"=>\"69\"}>]\n</user></pre>\n<h2>データの削除</h2>\nデータの削除(Delete)はdeleteメソッドや、destroyメソッドを使用します。\n<pre lang=\"ruby\">\nUser.delete(1) # ID = 1を削除\n\nuser = User.find(:first, :conditions => {:name => \"UK\"})\nuser.destory # name が \"UK\"のデータを削除\n</pre>\n<h2>雑感</h2>\nとりあえずざっとActiveRecordに触れてみましたが、DBをRubyのオブジェクトのように扱えるのは思いの外気持ちがいいですなー。ただ、プライマリーキー名が\"id\"固定なところやテーブル名を複数形云々のあたりが気になる人はいるのかなぁと。あと複合キーとかどうするんだーとか。そういうところを気にしないので済むのであれば、ActiveRecordはかなり良いと思います。\n<p>それにしてもコードがみづらいことこの上ないですね・・・そのうちなんとかしたいところです。</p>\n<p><a href=\"http://www.amazon.com/gp/redirect.html%3FASIN=1590598474%26tag=ukstudio0c-22%26lcode=xm2%26cID=2025%26ccmID=165953%26location=/o/ASIN/1590598474%253FSubscriptionId=1N9AHEAQ2F6SVD97BE02\" title=\"Click and drag this image to the post editor\"><img src=\"http://ecx.images-amazon.com/images/I/21rVApqb6cL.jpg\" width=\"121\"></a></p>","frontmatter":{"title":"ActiveRecordを使ってみる","date":"October 28, 2007","description":null}},"previous":{"fields":{"slug":"posts//2007/10/28/ruby_fizzbuzz/"},"frontmatter":{"title":"RubyでFizzBuzz"}},"next":{"fields":{"slug":"posts//2007/10/30/ruby_prime/"},"frontmatter":{"title":"Rubyで素数を求めるプログラムを書いた"}}},"pageContext":{"id":"fdbd5936-2332-5fa3-9266-9f586e630578","previousPostId":"44547e90-941a-556f-8b61-634632c19d39","nextPostId":"e3e98b47-e10e-589c-9b14-27669aad49f8"}},"staticQueryHashes":["2841359383"]}