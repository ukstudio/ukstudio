{"componentChunkName":"component---src-templates-blog-post-js","path":"/posts//2012/09/11/validates_presence_of/","result":{"data":{"site":{"siteMetadata":{"title":"UKSTUDIO BLOG"}},"markdownRemark":{"id":"07fe82a0-58b2-5430-9237-e2a42e029656","excerpt":"チームメンバーから「validatespresenceof :useridはそのuseridが存在するか確かめてくれる」という情報を得て、そんな隠れ仕様あんの?とおもってちょっと調べてみた。 結論だけまず言うと ではなく、 の用に関連名を指定するとそれっぽい動作をしなくもない。 とりあえずコードを追うとpresence…","html":"<p>チームメンバーから「validates<em>presence</em>of :user<em>idはそのuser</em>idが存在するか確かめてくれる」という情報を得て、そんな隠れ仕様あんの?とおもってちょっと調べてみた。</p>\n<p>結論だけまず言うと</p>\n<pre>\nvalidates :user_id, :presence => true\nvalidates_presence_of :user_id\n</pre>\n<p>ではなく、</p>\n<pre>\nvalidates :user, :presence => true\nvalidates_presence_of :user, :presence => true\n</pre>\n<p>の用に関連名を指定するとそれっぽい動作をしなくもない。</p>\n<p>とりあえずコードを追うとpresence系のバリデーション自体はActiveModel::Validations::PresenceValidatorで定義されている。</p>\n<pre>module ActiveModel\n  # == Active Model Presence Validator\n  module Validations\n    class PresenceValidator < EachValidator\n      def validate(record)\n        record.errors.add_on_blank(attributes, options)\n</pre>\n<p>次にadd<em>on</em>blankを見てみる。</p>\n<pre># File activemodel/lib/active_model/errors.rb, line 251\ndef add_on_blank(attributes, options = {})\n  [attributes].flatten.each do |attribute|\n    value = @base.send(:read_attribute_for_validation, attribute)\n    add(attribute, :blank, options) if value.blank?\n  end\nend\n</pre>\n<p>add<em>on</em>blankメソッドはattributesの内容を走査してblankだったらerrorsに追加してるんだろうなーというのが読み取れる。じゃあ実際に値を取ってきてるであろう:read<em>attribute</em>for_validationは何なのだろう。api.rubyonrails.orgで検索してもヒットしない。仕方ないからgitリポジトリをgrepして探す。そうすると以下の様なコードがみつかる。</p>\n<pre># activemodel/lib/active_model/validations.rb line 327\nalias :read_attribute_for_validation :send\n</pre>\n<p>つまりただのsend。なので</p>\n<pre>validates :user_id, :presence => true</pre>\n<p>というコードは</p>\n<pre>instance.send(:send, :user_id)</pre>\n<p>となり、結局は普通に指定した属性の値を見るに過ぎない。</p>\n<p>で、最初の話に戻るが</p>\n<pre>\nvalidates :user_id, :presence => true\n</pre>\n<p>は普通にuser<em>idの値がblank?かどうかだけを見るので実際にそのuser</em>idでUserが存在するかチェックはしない。</p>\n<pre>\nvalidates :user, :presence => true\n</pre>\n<p>はどうかというと、instance.userがnilの状態でinstance.userを呼び出すとinstance.user_idでUserを取りにいく。そこでUserが存在しなければ[]が返ってくるのでblank?がtrueとなりこのバリデーションは失敗する。</p>\n<pre>\ninstance = Model.new\ninstance.user_id = 111111111\ninstance.valid? #=> false\n  User Load (3.4ms)  SELECT \"users\".* FROM \"users\" WHERE \"\".\"id\" = 111111111 LIMIT 1\n</pre>\n<p>なので、このケースに限って言えばそのIDのレコードが存在するか確認する動作をしている。とは言え、あくまでisntance.userの値を見るだけなので</p>\n<pre>\ninstance = Model.new\ninstance.user = User.new\ninstance.valid? #=> true\n</pre>\n<p>この様に直接値を入れてしまえばDBにselect文はなげない。</p>\n<p>なので、そういう動作をすることもあるだけで厳密にはそのIDのレコードが存在を確かめているわけではない。</p>","frontmatter":{"title":"validates :foo_id, :presence => trueを追う","date":"September 11, 2012","description":null}},"previous":{"fields":{"slug":"posts//2012/09/11/ripping_cd_on_gentoo/"},"frontmatter":{"title":"GentooでCDをリッピングして聞く"}},"next":{"fields":{"slug":"posts//2013/10/18/middleman/"},"frontmatter":{"title":"ブログをWordPressからmiddlemanに移行しました"}}},"pageContext":{"id":"07fe82a0-58b2-5430-9237-e2a42e029656","previousPostId":"0be350ab-5754-575d-80e5-b97fa1068b11","nextPostId":"b411a06d-f7b3-5a07-afcc-9b8689fe8caf"}},"staticQueryHashes":["2841359383"]}